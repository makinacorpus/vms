# -*- mode: ruby -*-
# vim: set ft=ruby ts=2 et sts=2 tw=0 ai:
require 'yaml'
require 'digest/md5'
require 'etc'
# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!
VAGRANTFILE_API_VERSION = "2"
CWD = File.dirname(__FILE__)
SCWD = CWD.gsub(/\//, '_').slice(1..-1)
if File.exists? "#{CWD}/vagrant_config.rb"
    raise "Migrate your vagrant_config.rb to vagrant_config.yml (same variables but in yaml format)"
end

def eprintf(*args)
  $stdout = STDERR
  printf(*args)
  $stdout = STDOUT
end

class Hash
  def setdefault(key, value)
    if self[key].nil?
      self[key] = value
    else
      self[key]
    end
  end
end

# detect current host OS
def os
  @os ||= (
    host_os = RbConfig::CONFIG['host_os']
    case host_os
    when /darwin|mac os/
      :macosx
    when /linux/
      :linux
    when /solaris|bsd/
      :unix
    else
      raise Error::WebDriverError, "Non supported os: #{host_os.inspect}"
    end
  )
end

# Check entries in the configuration zone for variables available.
# --- Start Load optional config file ---------------
def get_uuid(machine)
    uuid_file = "#{CWD}/.vagrant/machines/#{machine}/virtualbox/id"
    uuid = nil
    if File.exist?(uuid_file)
        uuid = File.read(uuid_file).strip()
    end
    uuid
end

cfg = Hash.new
# Number of machines to spawn
cfg['DEVHOST_NUM'] = nil
cfg['UNAME'] = `uname`.strip
# Number of machines to spawn
cfg['MACHINES'] = 1
# Per Machine resources quotas
cfg['MEMORY'] = 1024
cfg['CPUS'] = 2
cfg['MAX_CPU_USAGE_PERCENT'] = 50
# network & misc devhost settings
cfg['AUTO_UPDATE_VBOXGUEST_ADD'] = true
# OS
cfg['OS'] = 'Ubuntu'
cfg['OS_RELEASE'] = 'xenial'

# load settings from a local file in case
localcfg = Hash.new
VSETTINGS_Y = "#{CWD}/vagrant_config.yml"
if File.exist?(VSETTINGS_Y)
  localcfg = YAML.load_file(VSETTINGS_Y)
  if ! localcfg then localcfg = Hash.new end
end
cfg = cfg.merge(localcfg)

# Can be overidden by env. (used by manage.sh import/export)
cfg.each_pair { |i, val| cfg[i] = ENV.fetch("DEVHOST_#{i}", val) }
['BOX', 'BOX_URI', 'BOX_PRIVATE_SUBNET_BASE', 'BOX_PRIVATE_SUBNET'].each do |i|
    val = ENV.fetch("DEVHOST_#{i}", nil)
    if val != nil then cfg[i] = val end
end

# IP managment
# The box used a default NAT private IP, defined automatically by vagrant and virtualbox
# It also use a private deticated network (automatically created in virtualbox on a vmX network)
# By default the private IP will be 10.1.XX.YY/24. This is used for file share, but, as you will have a fixed
# IP for this VM it could be used in your /etc/host file to reference any name on this vm
# (the default devhostYY.local or devhotsXX.local entry is managed by salt).
# If you have several VMs you may need to alter at least the DEVHOST_NUM to obtain a different IP network
# Be sure to have only one unique subnet per devhost per physical host
if not cfg['DEVHOST_NUM']
    consumed_nums = []
    skipped_nums = ["1", "254"]
    `VBoxManage list vms|grep -i devhost`.split(/\n/).each do |l|
      n = l.downcase.sub(/.*devhost ([0-9]*) .*/, '\\1')
      if not consumed_nums.include?(n) and not n.empty?
          consumed_nums << n
      end
    end
    ("1".."254").each do |num|
      if !consumed_nums.include?(num) && !skipped_nums.include?(num)
        cfg['DEVHOST_NUM'] = num
        break
      end
    end
    if not cfg['DEVHOST_NUM']
      raise "There is no devhosts numbers left in (#{consumed_nums})"
    end
end
localcfg['DEVHOST_NUM'] = cfg['DEVHOST_NUM']

# NETWORK
cfg.setdefault('BOX_PRIVATE_SUBNET_BASE', "10.1.")
cfg.setdefault('BOX_PRIVATE_SUBNET', "#{cfg['BOX_PRIVATE_SUBNET_BASE']}#{cfg['DEVHOST_NUM']}")

# BOX SELECTION
cfg.setdefault('BOX', "#{cfg['OS_RELEASE']}64")
cfg.setdefault('BOX_URI',
               "http://cloud-images.ubuntu.com/vagrant/"\
               "#{cfg['OS_RELEASE']}/current/#{cfg['OS_RELEASE']}-server-cloudimg-amd64-vagrant-disk1.box")

# save back config to yaml (mainly for persiting devhost_num)
File.open("#{VSETTINGS_Y}", 'w') {|f| f.write localcfg.to_yaml }

#------------ Computed variables ------------------------
cfg['VIRTUALBOX_BASE_VM_NAME'] = "DevHost #{cfg['DEVHOST_NUM']} #{cfg['OS']} #{cfg['OS_RELEASE']}64"
cfg['VM_HOST'] = "devhost#{cfg['DEVHOST_NUM']}"

Vagrant.configure("2") do |config|
  config.vbguest.auto_update = cfg['AUTO_UPDATE_VBOXGUEST_ADD']
  config.vbguest.auto_reboot = true
  config.vbguest.no_install = false
  # disable default /vagrant shared folder
  config.vm.synced_folder ".", "/vagrant", disabled: true
  (1..cfg['MACHINES'].to_i).each do |machine_num|
     hostname = "#{cfg['VM_HOST']}-#{machine_num}"
     machine = hostname
     config.vm.define  machine do |sub|
       box_private_ip = cfg['BOX_PRIVATE_SUBNET']+".#{machine_num + 1}"
       fqdn = "#{machine}.local"
       virtualbox_vm_name = "#{cfg['VIRTUALBOX_BASE_VM_NAME']} #{machine_num} (#{SCWD})"
       sub.vm.box = cfg['BOX']
       sub.vm.box_url = cfg['BOX_URI']
       if machine_num > 1
           sub.vm.host_name = fqdn
       else
           sub.vm.host_name = fqdn
       end
       sub.vm.provider "virtualbox" do |vb|
           vb.name = "#{virtualbox_vm_name}"
       end
       sub.vm.network "private_network", ip: box_private_ip, adapter: 2
       # vagrant 1.3 HACK: provision is now run only at first boot, we want to run it every time
       if File.exist?("#{CWD}/.vagrant/machines/#{machine}/virtualbox/action_provision")
         File.delete("#{CWD}/.vagrant/machines/#{machine}/virtualbox/action_provision")
       end
    end
  end
end

Vagrant.configure("2") do |config|
  config.vm.provider :virtualbox do |vb|
    vb.customize ["modifyvm", :id, "--ioapic", "on"]
    vb.customize ["modifyvm", :id, "--memory", cfg['MEMORY']]
    vb.customize ["modifyvm", :id, "--cpus", cfg['CPUS']]
    vb.customize ["modifyvm", :id, "--cpuexecutioncap", cfg['MAX_CPU_USAGE_PERCENT']]
    vb.customize ["modifyvm", :id, "--nicpromisc2", "allow-all"]
  end
end
